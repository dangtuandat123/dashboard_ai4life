Phân Tích Kỹ Thuật: Dashboard Doanh Thu Sản Phẩm

Tài liệu này giải thích logic lập trình đằng sau giao diện, tập trung vào 3 kỹ thuật khó nhất: Layout, Vẽ đường nối động (Dynamic SVG), và Hiệu ứng Neon (Styling).

1. Tư Duy Bố Cục (Layout Strategy)

Giao diện được chia thành 3 cột chính, sử dụng Flexbox để dàn trang.

Container Chính: flex-row items-start gap-16.

items-start: Giúp các cột bắt đầu từ trên cùng, quan trọng vì chiều cao các cột không giống nhau.

gap-16: Tạo khoảng trống lớn để chứa các đường nối (connector).

Cột 1 (KPI Card): Cố định vị trí.

Cột 2 (Danh sách Dòng sản phẩm): Chứa state điều khiển chính (activeLineId). Đây là "bộ não" điều hướng của cả dashboard.

Cột 3 (Chi tiết Loại sản phẩm): Nội dung thay đổi động (Dynamic Content) dựa vào lựa chọn ở Cột 2.

2. Kỹ Thuật "Đường Nối Ma Thuật" (The Magic Lines)

Đây là phần phức tạp nhất. Làm sao để vẽ một đường nối từ một item đang chọn sang nhiều item đích mà vị trí của chúng luôn thay đổi?

Bước 1: Hệ tọa độ

Chúng ta sử dụng một thẻ <svg> trong suốt (pointer-events-none) đặt đè lên khu vực giữa Cột 2 và Cột 3.

Gốc tọa độ (0,0) của SVG được đặt trùng với góc trên-trái của danh sách ở Cột 2.

Bước 2: Tính điểm xuất phát (Source Y)

Item ở Cột 2 có chiều cao cố định (48px) và khoảng cách (16px).
Công thức toán học đơn giản:

// Index của item đang chọn * (Chiều cao + Gap) + Một nửa chiều cao để vào tâm
const sourceY = (activeIndex * (48 + 16)) + 24;


Bước 3: Tính điểm đích (Target Y) - Kỹ thuật khó

Các thẻ ở Cột 3 có chiều cao không cố định (do tên sản phẩm có thể dài 1 dòng hoặc 2 dòng). Chúng ta không thể dùng công thức toán học tĩnh.

Giải pháp: Đo đạc thực tế (Dynamic Measurement)

Gắn ref vào container gốc (middleListRef) và từng thẻ con bên phải (rightCardRefs).

Sử dụng useLayoutEffect (chạy sau khi DOM render nhưng trước khi user nhìn thấy).

Dùng hàm getBoundingClientRect() để lấy tọa độ thực tế của các thẻ trên màn hình.

// Đo khoảng cách chênh lệch giữa Top của thẻ con và Top của container cha
const relativeTop = cardRect.top - middleRect.top;
const centerY = relativeTop + (cardRect.height / 2); // Cộng thêm nửa chiều cao để vào tâm


Bước 4: Vẽ đường (SVG Path)

Sau khi có tọa độ sourceY và mảng targetYPositions, ta vẽ đường gấp khúc bằng thẻ <path>:

M 0,sourceY: Di chuyển đến điểm xuất phát.

L 32,sourceY: Vẽ ngang sang phải 32px.

L 32,targetY: Vẽ dọc xuống đến độ cao của đích.

L 64,targetY: Vẽ ngang vào đích.

3. Quản Lý Trạng Thái (State Management)

Logic tương tác rất đơn giản:

State: const [activeLineId, setActiveLineId] = useState(1);

Hành động: Khi click vào một item ở Cột 2 -> Cập nhật activeLineId.

Phản ứng (Re-render):

Cột 2: Item có ID tương ứng sẽ đổi màu (Active Style).

Cột 3: displayedProductTypes được tính toán lại -> Render danh sách mới.

SVG: useLayoutEffect chạy lại -> Tính toán tọa độ mới -> Vẽ lại dây.

4. Hiệu Ứng Neon & Dark Mode (Styling)

Để tạo cảm giác "Công nghệ/Cyberpunk":

Màu nền: Không dùng màu đen tuyền (#000), dùng màu xanh đen rất đậm (#020617 - Slate 950) để tạo chiều sâu.

Glow (Phát sáng): Sử dụng drop-shadow trong SVG và box-shadow trong CSS.

Ví dụ: shadow-[0_0_15px_rgba(34,211,238,0.4)] tạo vùng sáng mờ màu Cyan xung quanh thanh tiến độ.

Gradient: Dùng bg-gradient-to-r để các thanh màu không bị đơn điệu (Ví dụ: từ Hồng sang Đỏ).

Border mỏng: Các thẻ tối màu cần có border rất mờ (border-slate-700) để tách biệt khỏi nền tối.

Tóm tắt quy trình code một tính năng mới:

Định nghĩa Data: Thêm field mới vào mảng dữ liệu (ví dụ: icon).

Cập nhật JSX: Render field đó ra màn hình.

Kiểm tra Layout: Xem field mới có làm vỡ layout hay thay đổi chiều cao thẻ không. (May mắn là logic SVG tự động tính lại chiều cao nên bạn không cần sửa code vẽ dây!).